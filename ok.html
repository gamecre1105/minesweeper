<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>5×5 マインスイーパー + 位置と音</title>
<style>
  :root{
    --board-size: min(92vmin, 420px);
    --cell-gap: 6px;
    --cell-radius: 10px;
    --bg: #0f1220;
    --panel: #171a2b;
    --text: #e8ecf3;
    --muted: #a9b0c3;
    --accent: #4dd0e1;
    --danger: #ff6b6b;
    --ok: #a5d6a7;
  }
  *{ box-sizing: border-box; }
  html,body{
    height:100%; margin:0; color:var(--text);
    background: radial-gradient(1200px 600px at 10% -10%, #1e2240, transparent), var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue",
                 "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, Arial, sans-serif;
  }
  .wrap{ max-width: 920px; margin: 24px auto; padding: 16px; display: grid; gap: 16px; }
  h1{ margin: 8px 0 0; font-size: clamp(20px, 5vw, 28px); letter-spacing:.02em; display:flex; align-items:center; gap:.5rem; }
  h1 .face{ font-size: 1.2em; cursor: pointer; user-select: none; transition: transform .15s; }
  h1 .face:active{ transform: scale(.95); }

  .grid{
    display: grid;
    grid-template-columns: 1fr;
    gap: 16px;
  }
  @media (min-width: 860px){
    .grid{ grid-template-columns: 1fr 1fr; align-items:start; }
  }

  .card{
    background: var(--panel);
    border-radius: 14px;
    padding: 12px 14px;
    box-shadow: 0 8px 16px rgba(0,0,0,.25), inset 0 8px 22px rgba(0,0,0,.15);
  }
  .card h2{ margin:.2rem 0 .6rem; font-size: 1.05rem; color:#cfd5e7; letter-spacing:.02em; }

  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .item{ display:flex; align-items:center; gap:8px; background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.06); padding: 8px 10px; border-radius: 12px; font-weight: 600; }
  .label{ color: var(--muted); font-weight:500; }
  .btn{ cursor:pointer; border:none; border-radius: 12px; padding: 9px 12px; font-weight:700;
        background: linear-gradient(180deg, #2a2f52, #212544); color: var(--text);
        box-shadow: 0 6px 18px rgba(0,0,0,.3); transition: transform .12s, filter .12s; }
  .btn:hover{ filter: brightness(1.05); }
  .btn:active{ transform: translateY(1px) scale(.99); }
  .hint{ color: var(--muted); font-size: .9rem; margin-top: 6px; }

  /* Board */
  .board{ width: var(--board-size); height: var(--board-size); margin: 8px auto 0; display:grid; grid-template-columns: repeat(5, 1fr); gap: var(--cell-gap); touch-action: manipulation; }
  .cell{
    user-select: none;
    display:grid; place-items:center;
    background: linear-gradient(180deg, #2c3157, #24294a);
    border: 1px solid rgba(255,255,255,.08);
    border-bottom-color: rgba(0,0,0,.5);
    border-radius: var(--cell-radius);
    box-shadow: 0 3px 0 rgba(0,0,0,.45), 0 10px 18px rgba(0,0,0,.25);
    color:#fff; font-weight:800; font-size: clamp(18px, 6vmin, 26px);
    aspect-ratio: 1/1; cursor:pointer; position:relative; outline:none;
  }
  .cell:focus-visible{ box-shadow: 0 0 0 3px #4dd0e155, 0 3px 0 rgba(0,0,0,.45), 0 10px 18px rgba(0,0,0,.25); }
  .cell.revealed{
    background: linear-gradient(180deg, #1b203c, #171a31);
    border-color: rgba(255,255,255,.05);
    box-shadow: inset 0 8px 20px rgba(0,0,0,.45);
    cursor: default;
  }
  .cell.mine.revealed{ background: linear-gradient(180deg, #401c2a, #2c1420); }
  .cell.flag::after{ content:"🚩"; position:absolute; font-size: clamp(18px, 6vmin, 26px); }
  .cell.mine.revealed::after{ content:"💣"; filter: drop-shadow(0 0 6px rgba(0,0,0,.4)); }
  .n1{ color:#4fc3f7; } .n2{ color:#81c784; } .n3{ color:#e57373; } .n4{ color:#9575cd; }
  .n5{ color:#ffb74d; } .n6{ color:#4db6ac; } .n7{ color:#90a4ae; } .n8{ color:#ef5350; }

  .footer{ text-align:center; color:var(--muted); margin-top:8px; font-size:.9rem;}

  /* Result modal */
  .result[hidden]{ display:none }
  .result{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,.35); backdrop-filter: blur(2px); z-index: 10;
  }
  .result .card{ min-width: 240px; text-align:center; }
  .result h2{ margin:.3rem 0 .6rem }

  /* tiny badge colors */
  .ok{ color: var(--ok); } .warn{ color:#ffcc80; } .err{ color: var(--danger); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:.95em; }
</style>
</head>
<body>
<div class="wrap">
  <h1><span class="face" id="face" title="リセット">🙂</span> 5×5 マインスイーパー</h1>

  <div class="grid">

    <!-- Left: Game -->
    <div class="card">
      <h2>ゲーム</h2>
      <div class="row" style="margin-bottom:8px;">
        <div class="item"><span class="label">地雷</span><span id="minesLeft">--</span></div>
        <div class="item"><span class="label">タイム</span><span id="timer">0.0</span>s</div>
        <button class="btn" id="resetBtn">リセット</button>
        <div class="item">
          <span class="label">音量</span>
          <input id="vol" type="range" min="0" max="1" step="0.01" value="0.6" />
          <button class="btn" id="testSound" title="テスト再生">🔊</button>
        </div>
      </div>
      <div class="hint">PC: 左クリック=開く / 右クリック=旗 ｜ スマホ: <b>長押し</b>=旗 ｜ キー: 矢印/Enter/F</div>
      <div class="board" id="board" aria-label="マインスイーパー盤面"></div>
      <div class="footer">最初のクリックは安全です。クリアしたら顔が<span style="filter:hue-rotate(25deg)">😎</span>に！</div>
    </div>

    <!-- Right: Environment / Location -->
    <div class="card">
      <h2>環境と位置</h2>
      <div class="row">
        <div class="item">
          <span class="label">接続</span>
          <span id="httpsState" class="mono">checking…</span>
        </div>
        <div class="item">
          <span class="label">タイムゾーン</span>
          <span id="tz" class="mono">--</span>
        </div>
        <div class="item">
          <span class="label">ローカル時刻</span>
          <span id="now" class="mono">--</span>
        </div>
      </div>
      <div class="hint" id="httpsHint"></div>

      <hr style="border-color:rgba(255,255,255,.07);border-width:0 0 1px;margin:10px 0">

      <div class="row" style="gap:8px;">
        <button class="btn" id="btnGeo">精密位置（GPS/Wi-Fi）</button>
        <button class="btn" id="btnIp">概略位置（IPベース）</button>
        <button class="btn" id="btnClear">表示クリア</button>
      </div>
      <div class="hint">※ 精密位置はブラウザの許可が必要。IPベースは市区町村レベルで概算（外部API利用、IPが送信されます）。</div>

      <div id="locOutput" class="mono" style="margin-top:8px; white-space:pre-wrap;"></div>
    </div>

  </div>
</div>

<!-- Result modal -->
<div id="result" class="result" hidden>
  <div class="card">
    <div id="resultEmoji" style="font-size:40px">😎</div>
    <h2 id="resultText">CLEAR!</h2>
    <p>タイム: <span id="finalTime">0.0</span>s</p>
    <button class="btn" id="againBtn">もう一回</button>
  </div>
</div>

<script>
(() => {
  /* =======================
     🔊 Sound (hit.mp3)
  ======================= */
  const audioSrc = "./hit.mp3"; // 同じフォルダに置く
  const seBase = new Audio(audioSrc);
  seBase.preload = "auto";
  let volume = 0.6;
  const setVolume = v => { volume = Math.max(0, Math.min(1, v)); };

  // 初回タップで解錠（モバイル自動再生対策）
  const unlock = () => {
    seBase.volume = 0.0001;
    seBase.play().then(() => { seBase.pause(); seBase.currentTime = 0; })
      .finally(() => document.removeEventListener('pointerdown', unlock, true));
  };
  document.addEventListener('pointerdown', unlock, true);

  function playSE(rate = 1.0){
    const a = seBase.cloneNode();
    a.volume = volume;
    a.playbackRate = rate;
    a.play().catch(()=>{ /* 再生不可は無視 */ });
  }

  /* =======================
     ⛏️ Minesweeper
  ======================= */
  const W = 5, H = 5, MINES = 5, LONG_PRESS_MS = 420;

  let board = [];
  let firstClick = true;
  let flags = 0;
  let revealedCount = 0;
  let startTime = 0;
  let timerId = null;

  const elBoard = document.getElementById('board');
  const elMinesLeft = document.getElementById('minesLeft');
  const elTimer = document.getElementById('timer');
  const elReset = document.getElementById('resetBtn');
  const elFace = document.getElementById('face');
  const elVol = document.getElementById('vol');
  const elTest = document.getElementById('testSound');

  // result modal
  const elResult = document.getElementById('result');
  const elResultEmoji = document.getElementById('resultEmoji');
  const elResultText  = document.getElementById('resultText');
  const elFinalTime   = document.getElementById('finalTime');
  const elAgain       = document.getElementById('againBtn');

  const inBounds = (x,y) => x>=0 && y>=0 && x<W && y<H;
  const neighbors = (x,y) => {
    const res=[];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(inBounds(nx,ny)) res.push({x:nx,y:ny});
      }
    }
    return res;
  };

  function startTimer(){
    startTime = performance.now();
    const tick = () => {
      const t = (performance.now() - startTime)/1000;
      elTimer.textContent = t.toFixed(1);
      timerId = requestAnimationFrame(tick);
    };
    timerId = requestAnimationFrame(tick);
  }
  function stopTimer(){
    if(timerId){ cancelAnimationFrame(timerId); timerId = null; }
  }

  function createEmptyBoard(){
    board = [];
    elBoard.innerHTML = '';
    elBoard.style.gridTemplateColumns = `repeat(${W}, 1fr)`;
    for(let y=0;y<H;y++){
      const row=[];
      for(let x=0;x<W;x++){
        const el = document.createElement('button');
        el.className = 'cell';
        el.setAttribute('data-x', x);
        el.setAttribute('data-y', y);
        el.setAttribute('aria-label', '未開封');
        el.tabIndex = 0;
        attachCellEvents(el);
        elBoard.appendChild(el);
        row.push({ x, y, mine:false, adj:0, revealed:false, flagged:false, el });
      }
      board.push(row);
    }
    flags = 0; revealedCount = 0; firstClick = true;
    elMinesLeft.textContent = MINES;
    elTimer.textContent = '0.0';
    elFace.textContent = '🙂';
    stopTimer();
  }

  function placeMines(excludeX, excludeY){
    let placed = 0;
    while(placed < MINES){
      const x = Math.floor(Math.random()*W);
      const y = Math.floor(Math.random()*H);
      if((x===excludeX && y===excludeY) || board[y][x].mine) continue;
      board[y][x].mine = true;
      placed++;
    }
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(board[y][x].mine){ board[y][x].adj = -1; continue; }
        board[y][x].adj = neighbors(x,y).reduce((n,p)=> n + (board[p.y][p.x].mine?1:0), 0);
      }
    }
  }

  function attachCellEvents(el){
    el.addEventListener('click', () => {
      const {x,y} = getXY(el);
      onReveal(x,y);
    });
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const {x,y} = getXY(el);
      onToggleFlag(x,y);
    });

    let pressTimer = null, pressed = false, moved = false;
    el.addEventListener('pointerdown', (e) => {
      pressed = true; moved = false;
      if(e.pointerType === 'touch'){
        pressTimer = setTimeout(() => {
          if(pressed && !moved){
            const {x,y} = getXY(el);
            onToggleFlag(x,y);
          }
        }, LONG_PRESS_MS);
      }
    });
    el.addEventListener('pointermove', () => { moved = true; });
    const cancelPress = () => { pressed = false; if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } };
    el.addEventListener('pointerup', cancelPress);
    el.addEventListener('pointercancel', cancelPress);

    el.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      const {x,y} = getXY(el);
      if(key === 'enter'){ onReveal(x,y); }
      else if(key === 'f'){ onToggleFlag(x,y); }
      else if(['arrowup','arrowdown','arrowleft','arrowright'].includes(key)){
        e.preventDefault();
        const d = {arrowup:[0,-1], arrowdown:[0,1], arrowleft:[-1,0], arrowright:[1,0]}[key];
        const nx = Math.max(0, Math.min(W-1, x + d[0]));
        const ny = Math.max(0, Math.min(H-1, y + d[1]));
        board[ny][nx].el.focus();
      }
    });
  }
  const getXY = el => ({ x: +el.getAttribute('data-x'), y: +el.getAttribute('data-y') });

  function onToggleFlag(x,y){
    const c = board[y][x];
    if(c.revealed) return;
    c.flagged = !c.flagged;
    c.el.classList.toggle('flag', c.flagged);
    c.el.setAttribute('aria-label', c.flagged ? '旗' : '未開封');
    flags += c.flagged ? 1 : -1;
    elMinesLeft.textContent = Math.max(0, MINES - flags);
    playSE(1.25); // 旗の音
    checkWin();
  }

  function onReveal(x,y){
    if(firstClick){
      placeMines(x,y);
      firstClick = false;
      startTimer();
    }
    const c = board[y][x];
    if(c.revealed || c.flagged) return;

    c.revealed = true;
    c.el.classList.add('revealed');
    c.el.removeAttribute('tabindex');
    revealedCount++;

    if(c.mine){
      revealAllMines(c);
      playSE(0.8); // どーん
      gameOver(false);
      return;
    }

    if(c.adj>0){
      c.el.textContent = c.adj;
      c.el.classList.add('n'+c.adj);
      c.el.setAttribute('aria-label', `数${c.adj}`);
      playSE(1.0);
    }else{
      c.el.textContent = '';
      c.el.setAttribute('aria-label', '空白');
      playSE(1.05);
      floodFill(x,y);
    }
    checkWin();
  }

  function floodFill(sx,sy){
    const q = [{x:sx,y:sy}];
    const seen = new Set([sx+','+sy]);
    while(q.length){
      const {x,y} = q.shift();
      for(const p of neighbors(x,y)){
        const c = board[p.y][p.x];
        if(c.revealed || c.flagged) continue;
        c.revealed = true;
        c.el.classList.add('revealed');
        c.el.removeAttribute('tabindex');
        revealedCount++;
        if(c.mine) continue;
        if(c.adj>0){
          c.el.textContent = c.adj;
          c.el.classList.add('n'+c.adj);
          c.el.setAttribute('aria-label', `数${c.adj}`);
        }else{
          c.el.textContent = '';
          c.el.setAttribute('aria-label', '空白');
          const key = p.x+','+p.y;
          if(!seen.has(key)){
            seen.add(key);
            q.push({x:p.x,y:p.y});
          }
        }
      }
    }
  }

  function revealAllMines(trigger){
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const c = board[y][x];
        if(c.mine){
          c.el.classList.add('revealed','mine');
          c.el.textContent = '';
        }
      }
    }
    if(trigger){ trigger.el.style.outline = '2px solid var(--danger)'; }
  }

  function checkWin(){
    const safeCells = W*H - MINES;
    if(revealedCount >= safeCells){
      playSE(1.5);
      gameOver(true);
    }
  }

  function gameOver(win){
    stopTimer();
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        board[y][x].el.style.pointerEvents = 'none';
      }
    }
    elFace.textContent = win ? '😎' : '💥';
    if(win){
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const c = board[y][x];
          if(c.mine && !c.flagged){ c.flagged = true; c.el.classList.add('flag'); }
        }
      }
      elMinesLeft.textContent = 0;
    }
    // modal
    elResultEmoji.textContent = win ? '😎' : '💥';
    elResultText.textContent  = win ? 'CLEAR!' : 'GAME OVER';
    elFinalTime.textContent   = (+elTimer.textContent).toFixed(1);
    elResult.hidden = false;
  }

  function reset(){
    createEmptyBoard();
    elResult.hidden = true;
  }

  elReset.addEventListener('click', reset);
  elFace.addEventListener('click', reset);
  elBoard.addEventListener('contextmenu', (e)=> e.preventDefault());
  elAgain.addEventListener('click', () => { elResult.hidden = true; reset(); });

  // volume UI
  elVol.addEventListener('input', e => setVolume(+e.target.value));
  elTest.addEventListener('click', () => playSE(1.0));

  reset();

  /* =======================
     🌏 Environment / Location
  ======================= */
  const elHttpsState = document.getElementById('httpsState');
  const elHttpsHint  = document.getElementById('httpsHint');
  const elTZ = document.getElementById('tz');
  const elNow = document.getElementById('now');
  const elLoc = document.getElementById('locOutput');

  // HTTPS check
  const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
  elHttpsState.textContent = isHttps ? 'HTTPS ✅' : (location.protocol + ' ⚠︎');
  elHttpsState.className = isHttps ? 'ok mono' : 'warn mono';
  elHttpsHint.textContent = isHttps ? '' : '位置情報(GPS/Wi-Fi)はHTTPSかlocalhostでのみ取得できます。GitHub Pagesのhttpsで開いてください。';

  // Timezone display
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown';
  const offMin = -new Date().getTimezoneOffset(); // JST=+540
  const sign = offMin >= 0 ? '+' : '-';
  const h = Math.floor(Math.abs(offMin)/60);
  const m = Math.abs(offMin)%60;
  const utc = `UTC${sign}${String(h).padStart(2,'0')}${m?':'+String(m).padStart(2,'0'):''}`;
  const abbr = (tz === 'Asia/Tokyo') ? 'JST' : utc;
  elTZ.textContent = `${abbr} (${utc})`;

  function tickNow(){
    elNow.textContent = new Date().toLocaleString();
    requestAnimationFrame(()=>setTimeout(tickNow, 500));
  }
  tickNow();

  // Buttons
  document.getElementById('btnGeo').addEventListener('click', () => {
    if(!isHttps){
      elLoc.textContent = '⚠ HTTPSではないためGeolocationは使えません。GitHub Pages(https)で開いてください。';
      return;
    }
    elLoc.textContent = '取得中...';
    const opts = { enableHighAccuracy: false, timeout: 10000, maximumAge: 60000 };
    navigator.geolocation.getCurrentPosition(
      pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        elLoc.textContent =
`精密位置: OK
lat: ${latitude.toFixed(6)}
lng: ${longitude.toFixed(6)}
精度: ±${Math.round(accuracy)} m`;
      },
      err => {
        const map = {1:'PERMISSION_DENIED(拒否)', 2:'POSITION_UNAVAILABLE(取得不能)', 3:'TIMEOUT(時間切れ)'};
        elLoc.textContent = `精密位置: 失敗\ncode: ${err.code} ${map[err.code]||''}\nmsg: ${err.message}`;
      },
      opts
    );
  });

  document.getElementById('btnIp').addEventListener('click', async () => {
    elLoc.textContent = '概略位置(IP)を取得中...';
    try{
      // 外部API: ipapi.co（市区町村レベルの概算）
      const r = await fetch('https://ipapi.co/json/');
      const d = await r.json();
      elLoc.textContent =
`概略位置(IP): OK
${d.city || '-'}, ${d.region || '-'}, ${d.country_name || '-'}
lat: ${d.latitude ?? '-'}, lng: ${d.longitude ?? '-'}
ISP: ${d.org || '-'}`
    }catch(e){
      elLoc.textContent = '概略位置(IP): 失敗\n' + e;
    }
  });

  document.getElementById('btnClear').addEventListener('click', () => elLoc.textContent = '');
})();
</script>
</body>
</html>
